"use strict";

var printFloat = function printFloat (v) {
    return (v === v|0 ? v.toPrecision(2) : v.toString(10));
};

var generateComment = function generateComment (what, rule, outOfBoundValue) {
    var comments = [
        '/**',
        ' * ' + what + ' generated by cellular-automata-voxel-shader 0.1.0',
        ' * ',
        ' * Rule : ' + rule.ruleString,
        ' * Out of bound value : ' + outOfBoundValue,
        ' */'
    ];

    return comments.join('\n');
};

var generateUniformsAndConstants = function generateUniformsAndConstants () {
    return [
        '// console command',
        '// \'xs [iterations] shadername\' : e.g. \'xs 20 shadername\'',
        '',
        '// shader inputs',
        '// uniform vec3    iVolumeSize;    // volume size [1-126]',
        '// uniform float   iColorIndex;    // current color index [1-255]',
        '// uniform vec3    iMirror;        // current mirror mode [0-1]',
        '// uniform vec3    iAxis;          // current axis mode [0-1]',
        '// uniform float   iFrame;         // current frame',
        '// uniform float   iArgs[8];       // user args',
        '',
        '// built-in functions',
        '// float voxel(vec3 v);'
    ].join('\n')
};

var generateGetVoxelGlsl = function generateGetVoxelGlsl (outOfBoundValue) {
    outOfBoundValue = outOfBoundValue || 0;

    if (outOfBoundValue === 'wrap') {
        return [
            'int getVoxel(const in vec3 currentPos, const in vec3 add) {',
            '  vec3 voxelPos = mod((currentPos + add), iVolumeSize);',
            '  return int(voxel(voxelPos));',
            '}'
        ].join('\n');
    } else {
        return [
            'int getVoxel(const in vec3 currentPos, const in vec3 add) {',
            '  vec3 voxelPos = (currentPos + add) ;',
            '  if(voxelPos.x < 0. || voxelPos.y < 0. || voxelPos.z < 0. || voxelPos.x >= iVolumeSize.x || voxelPos.y >= iVolumeSize.y || voxelPos.z >= iVolumeSize.z) {',
            '    return ' + outOfBoundValue + ';',
            '  } else {',
            '    return int(voxel(voxelPos));',
            '  }',
            '}'
        ].join('\n');
    }
};

var generateGetNeighbourhood = function (neighbourhood) {
    var glsl = [
        'int getNeighbourhood (const in vec3 currentPos) {',
        '  int sum = 0;',
        ''
    ];

    for (var i = 0; i < neighbourhood.length; i++) {
        var neighbour = neighbourhood[i];
        glsl.push('  sum += getVoxel(currentPos, vec3(' + printFloat(neighbour[0]) + ', ' + printFloat(neighbour[1]) + ', ' + printFloat(neighbour[2]) + ')) > 0 ? 1 : 0;');
    }

    glsl.push('', '  return sum;', '}');

    return glsl.join('\n');
};

var generateGetNeighbourhoodSum = function (neighbourhood) {
    var glsl = [
        'int getNeighbourhoodSum (const in vec3 currentPos) {',
        '  int sum = 0;',
        ''
    ];

    for (var i = 0; i < neighbourhood.length; i++) {
        var neighbour = neighbourhood[i];
        glsl.push('  sum += getVoxel(currentPos, vec3(' + printFloat(neighbour[0]) + ', ' + printFloat(neighbour[1]) + ', ' + printFloat(neighbour[2]) + '));');
    }

    glsl.push('', '  return sum;', '}');

    return glsl.join('\n');
};

var generateGetNeighbourhoodCond = function (neighbourhood) {
    var glsl = [
        'int getNeighbourhoodCond (const in vec3 currentPos, const in int desiredValue) {',
        '  int sum = 0;',
        ''
    ];

    for (var i = 0; i < neighbourhood.length; i++) {
        var neighbour = neighbourhood[i];
        glsl.push('  sum += getVoxel(currentPos, vec3(' + printFloat(neighbour[0]) + ', ' + printFloat(neighbour[1]) + ', ' + printFloat(neighbour[2]) + ')) == desiredValue ? 1 : 0;');
    }

    glsl.push('', '  return sum;', '}');

    return glsl.join('\n');
};

var generateNeighbourhoodGlsl = function generateNeighbourhoodGlsl (neighbourhood) {
    var glsl = [
        generateGetNeighbourhood(neighbourhood),
        '',
        generateGetNeighbourhoodSum(neighbourhood),
        '',
        generateGetNeighbourhoodCond(neighbourhood)
    ];

    return glsl.join('\n');
};

var generateProcessGlslGenerations = function generateProcessGlslGenerations (stateCount, survival, birth) {
    var birthString = [],
        survivalString = [],
        i;

    if (birth.length) {
        for (i = 0; i < birth.length; i++) {
            birthString.push('sum == ' + birth[i]);
        }
    } else {
        birthString.push('false');
    }

    if (survival.length) {
        for (i = 0; i < survival.length; i++) {
            survivalString.push('sum == ' + survival[i]);
        }
    } else {
        survivalString.push('false');
    }

    var glsl = [
        'int process(const in int currentValue, const in vec3 position) {',
        '  int sum = getNeighbourhoodCond(position, 1);',
        '  if (currentValue == 0 && (' + birthString.join(' || ') + ')) {',
        '    return 1;',
        '  } else if (currentValue == 1 && (' + survivalString.join(' || ') + ')) {',
        '    return 1;',
        '  } else if (currentValue > 0) {',
        '    return int(mod(float(currentValue + 1), ' + printFloat(stateCount) + '));',
        '  }',
        '  return 0;',
        '}'
    ];

    return glsl.join('\n');
};

var generateProcessGlslLife = function generateProcessGlslLife (survival, birth) {
    var birthString = [],
        survivalString = [],
        i;

    if (birth.length) {
        for (i = 0; i < birth.length; i++) {
            birthString.push('sum == ' + birth[i]);
        }
    } else {
        birthString.push('false');
    }

    if (survival.length) {
        for (i = 0; i < survival.length; i++) {
            survivalString.push('sum == ' + survival[i]);
        }
    } else {
        survivalString.push('false');
    }


    var glsl = [
        'int process(const in int currentValue, const in vec3 position) {',
        '  int sum = getNeighbourhood(position);',
        '  if (currentValue == 0 && (' + birthString.join(' || ') + ')) {',
        '    return 1;',
        '  } else if (currentValue > 0 && (' + survivalString.join(' || ') + ')) {',
        '    return 1;',
        '  }',
        '  return 0;',
        '}'
    ];

    return glsl.join('\n');
};

var generateProcessGlslVote = function generateProcessGlslVote (votes) {
    var voteString = [],
        i;

    if (votes.length) {
        for (i = 0; i < votes.length; i++) {
            voteString.push('sum == ' + votes[i]);
        }
    } else {
        voteString.push('false');
    }

    var glsl = [
        'int process(const in int currentValue, const in vec3 position) {',
        '  int sum = getNeighbourhood(position) + (currentValue > 0 ? 1 : 0);',
        '  if (' + voteString.join(' || ') + ') {',
        '    return 1;',
        '  }',
        '  return 0;',
        '}'
    ];

    return glsl.join('\n');
};

var generateProcessGlslLuky = function generateProcessGlslLuky (lowSurvival, highSurvival, lowBirth, highBirth) {
    var glsl = [
        'int process(const in int currentValue, const in vec3 position) {',
        '  int sum = getNeighbourhood(position);',
        '  if (currentValue == 0 && sum >= ' + lowBirth + ' && sum <= ' + highBirth + ') {',
        '    return 1;',
        '  } else if (currentValue > 0 && sum >= ' + lowSurvival + ' && sum <= ' + highSurvival + ') {',
        '    return 1;',
        '  }',
        '  return 0;',
        '}'
    ];

    return glsl.join('\n');
};

var generateProcessGlslNluky = function generateProcessGlslNluky (stateCount, lowSurvival, highSurvival, lowBirth, highBirth) {
    var glsl = [
        'int process(const in int currentValue, const in vec3 position) {',
        '  int sum = getNeighbourhoodCond(position, 1);',
        '  if (currentValue == 0 && sum >= ' + lowBirth + ' && sum <= ' + highBirth + ') {',
        '    return 1;',
        '  } else if (currentValue == 1 && sum >= ' + lowSurvival + ' && sum <= ' + highSurvival + ') {',
        '    return 1;',
        '  } else if (currentValue == 1) {',
        '    return ' + (2 % (2 + stateCount * 2)) + ';',
        '  } else if (currentValue >= 2) {',
        '    return int(mod(float(currentValue + 2), ' + printFloat(2 + stateCount * 2) + '));',
        '  }',
        '  return 0;',
        '}'
    ];

    return glsl.join('\n');
};

var generateProcessGlslCyclic = function generateProcessGlslCyclic (stateCount, threshold, greenbergHastingsModel) {
    var glsl = [
        'int process(const in int currentValue, const in vec3 position) {',
        '  int nextValue = int(mod(float(currentValue + 1), ' + printFloat(stateCount) + '));',
        '  int sum = getNeighbourhoodCond(position, nextValue);',
        '  if (sum >= ' + threshold + (greenbergHastingsModel ? ' || currentValue > 0' : '') + ') {',
        '    return nextValue;',
        '  }',
        '  return currentValue;',
        '}'
    ];

    return glsl.join('\n');
};

var generateProcessGlsl = function generateProcessGlsl (rule) {
    /*
     // debug process function
     var glsl = [
     'float process(const float currentValue, const int sum) {',
     '  return float(sum) / 255.;',
     '}'
     ];

     return glsl.join('\n');
     */

    if (rule.ruleFormat === 'life' || rule.ruleFormat === 'extended-life') {
        return generateProcessGlslLife(rule.survival, rule.birth);
    } else if (rule.ruleFormat === 'generations' || rule.ruleFormat === 'extended-generations') {
        return generateProcessGlslGenerations(rule.stateCount, rule.survival, rule.birth);
    } else if (rule.ruleFormat === 'vote') {
        return generateProcessGlslVote(rule.vote);
    } else if (rule.ruleFormat === 'luky') {
        return generateProcessGlslLuky(rule.lowSurvival, rule.highSurvival, rule.lowBirth, rule.highBirth);
    } else if (rule.ruleFormat === 'nluky') {
        return generateProcessGlslNluky(rule.stateCount, rule.lowSurvival, rule.highSurvival, rule.lowBirth, rule.highBirth);
    } else if (rule.ruleFormat === 'cyclic') {
        return generateProcessGlslCyclic(rule.stateCount, rule.threshold, rule.greenbergHastingsModel);
    }

    throw new Error('Unsupported ruleFormat : ' + rule.ruleFormat);
};

var generateGlsl = function generateGlsl (rule, neighbourhood, outOfBoundValue) {
    var glsl = [
        generateComment('Voxel Shader for MagicaVoxel 0.97.1', rule, outOfBoundValue),
        '',
        generateUniformsAndConstants(),
        '',
        generateGetVoxelGlsl(outOfBoundValue),
        '',
        generateNeighbourhoodGlsl(neighbourhood),
        '',
        generateProcessGlsl(rule),
        '',
        'float map(vec3 v) {',
        '  int currentValue = int(voxel(v));',
        '  return float(process(currentValue, v));',
        '}'
    ];

    return glsl.join('\n')
};

module.exports = generateGlsl;
